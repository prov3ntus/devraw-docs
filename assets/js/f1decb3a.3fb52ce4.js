"use strict";(self.webpackChunkdevraw_docs=self.webpackChunkdevraw_docs||[]).push([[494],{7632:(e,n,r)=>{r.r(n),r.d(n,{default:()=>f});var t=r(6540),o=r(9412),a=r(1171),i=r(4347),s=r(9630),u=r(4848);const c=e=>{const n=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return n?[parseInt(n[1],16)/255,parseInt(n[2],16)/255,parseInt(n[3],16)/255]:[1,1,1]},l=(e,n,r)=>{switch(e){case"top-left":return{anchor:[0,-.2*r],dir:[0,1]};case"top-right":return{anchor:[n,-.2*r],dir:[0,1]};case"left":return{anchor:[-.2*n,.5*r],dir:[1,0]};case"right":return{anchor:[1.2*n,.5*r],dir:[-1,0]};case"bottom-left":return{anchor:[0,1.2*r],dir:[0,-1]};case"bottom-center":return{anchor:[.5*n,1.2*r],dir:[0,-1]};case"bottom-right":return{anchor:[n,1.2*r],dir:[0,-1]};default:return{anchor:[.5*n,-.2*r],dir:[0,1]}}},f=({raysOrigin:e="top-center",raysColor:n="#ffffff",raysSpeed:r=1,lightSpread:f=1,rayLength:d=2,pulsating:v=!1,fadeDistance:m=1,saturation:g=1,followMouse:y=!0,mouseInfluence:h=.1,noiseAmount:p=0,distortion:C=0,className:w=""})=>{const x=(0,t.useRef)(null),R=(0,t.useRef)(null),D=(0,t.useRef)(null),S=(0,t.useRef)({x:.5,y:.5}),b=(0,t.useRef)({x:.5,y:.5}),A=(0,t.useRef)(null),P=(0,t.useRef)(null),I=(0,t.useRef)(null),[T,L]=(0,t.useState)(!1),E=(0,t.useRef)(null);return(0,t.useEffect)((()=>{if(x.current)return E.current=new IntersectionObserver((e=>{const n=e[0];L(n.isIntersecting)}),{threshold:.1}),E.current.observe(x.current),()=>{E.current&&(E.current.disconnect(),E.current=null)}}),[]),(0,t.useEffect)((()=>{if(!T||!x.current)return;I.current&&(I.current(),I.current=null);return(async()=>{if(!x.current)return;if(await new Promise((e=>setTimeout(e,10))),!x.current)return;const t=new o.A({dpr:Math.min(window.devicePixelRatio,2),alpha:!0});D.current=t;const u=t.gl;for(u.canvas.style.width="100%",u.canvas.style.height="100%";x.current.firstChild;)x.current.removeChild(x.current.firstChild);x.current.appendChild(u.canvas);const w={iTime:{value:0},iResolution:{value:[1,1]},rayPos:{value:[0,0]},rayDir:{value:[0,1]},raysColor:{value:c(n)},raysSpeed:{value:r},lightSpread:{value:f},rayLength:{value:d},pulsating:{value:v?1:0},fadeDistance:{value:m},saturation:{value:g},mousePos:{value:[.5,.5]},mouseInfluence:{value:h},noiseAmount:{value:p},distortion:{value:C}};R.current=w;const T=new a.l(u),L=new i.B(u,{vertex:"\nattribute vec2 position;\nvarying vec2 vUv;\nvoid main() {\n  vUv = position * 0.5 + 0.5;\n  gl_Position = vec4(position, 0.0, 1.0);\n}",fragment:"precision highp float;\n\nuniform float iTime;\nuniform vec2  iResolution;\n\nuniform vec2  rayPos;\nuniform vec2  rayDir;\nuniform vec3  raysColor;\nuniform float raysSpeed;\nuniform float lightSpread;\nuniform float rayLength;\nuniform float pulsating;\nuniform float fadeDistance;\nuniform float saturation;\nuniform vec2  mousePos;\nuniform float mouseInfluence;\nuniform float noiseAmount;\nuniform float distortion;\n\nvarying vec2 vUv;\n\nfloat noise(vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\n\nfloat rayStrength(vec2 raySource, vec2 rayRefDirection, vec2 coord,\n                  float seedA, float seedB, float speed) {\n  vec2 sourceToCoord = coord - raySource;\n  vec2 dirNorm = normalize(sourceToCoord);\n  float cosAngle = dot(dirNorm, rayRefDirection);\n\n  float distortedAngle = cosAngle + distortion * sin(iTime * 2.0 + length(sourceToCoord) * 0.01) * 0.2;\n  \n  float spreadFactor = pow(max(distortedAngle, 0.0), 1.0 / max(lightSpread, 0.001));\n\n  float distance = length(sourceToCoord);\n  float maxDistance = iResolution.x * rayLength;\n  float lengthFalloff = clamp((maxDistance - distance) / maxDistance, 0.0, 1.0);\n  \n  float fadeFalloff = clamp((iResolution.x * fadeDistance - distance) / (iResolution.x * fadeDistance), 0.5, 1.0);\n  float pulse = pulsating > 0.5 ? (0.8 + 0.2 * sin(iTime * speed * 3.0)) : 1.0;\n\n  float baseStrength = clamp(\n    (0.45 + 0.15 * sin(distortedAngle * seedA + iTime * speed)) +\n    (0.3 + 0.2 * cos(-distortedAngle * seedB + iTime * speed)),\n    0.0, 1.0\n  );\n\n  return baseStrength * lengthFalloff * fadeFalloff * spreadFactor * pulse;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 coord = vec2(fragCoord.x, iResolution.y - fragCoord.y);\n  \n  vec2 finalRayDir = rayDir;\n  if (mouseInfluence > 0.0) {\n    vec2 mouseScreenPos = mousePos * iResolution.xy;\n    vec2 mouseDirection = normalize(mouseScreenPos - rayPos);\n    finalRayDir = normalize(mix(rayDir, mouseDirection, mouseInfluence));\n  }\n\n  vec4 rays1 = vec4(1.0) *\n               rayStrength(rayPos, finalRayDir, coord, 36.2214, 21.11349,\n                           1.5 * raysSpeed);\n  vec4 rays2 = vec4(1.0) *\n               rayStrength(rayPos, finalRayDir, coord, 22.3991, 18.0234,\n                           1.1 * raysSpeed);\n\n  fragColor = rays1 * 0.5 + rays2 * 0.4;\n\n  if (noiseAmount > 0.0) {\n    float n = noise(coord * 0.01 + iTime * 0.1);\n    fragColor.rgb *= (1.0 - noiseAmount + noiseAmount * n);\n  }\n\n  float brightness = 1.0 - (coord.y / iResolution.y);\n  fragColor.x *= 0.1 + brightness * 0.8;\n  fragColor.y *= 0.3 + brightness * 0.6;\n  fragColor.z *= 0.5 + brightness * 0.5;\n\n  if (saturation != 1.0) {\n    float gray = dot(fragColor.rgb, vec3(0.299, 0.587, 0.114));\n    fragColor.rgb = mix(vec3(gray), fragColor.rgb, saturation);\n  }\n\n  fragColor.rgb *= raysColor;\n}\n\nvoid main() {\n  vec4 color;\n  mainImage(color, gl_FragCoord.xy);\n  gl_FragColor = color;\n}",uniforms:w}),E=new s.e(u,{geometry:T,program:L});P.current=E;const F=()=>{if(!x.current||!t)return;t.dpr=Math.min(window.devicePixelRatio,2);const{clientWidth:n,clientHeight:r}=x.current;t.setSize(n,r);const o=t.dpr,a=n*o,i=r*o;w.iResolution.value=[a,i];const{anchor:s,dir:u}=l(e,a,i);w.rayPos.value=s,w.rayDir.value=u},z=e=>{if(D.current&&R.current&&P.current){if(w.iTime.value=.001*e,y&&h>0){const e=.92;b.current.x=b.current.x*e+S.current.x*(1-e),b.current.y=b.current.y*e+S.current.y*(1-e),w.mousePos.value=[b.current.x,b.current.y]}try{t.render({scene:E}),A.current=requestAnimationFrame(z)}catch(n){return void console.warn("WebGL rendering error:",n)}}};window.addEventListener("resize",F),F(),A.current=requestAnimationFrame(z),I.current=()=>{if(A.current&&(cancelAnimationFrame(A.current),A.current=null),window.removeEventListener("resize",F),t)try{const e=t.gl.canvas,n=t.gl.getExtension("WEBGL_lose_context");n&&n.loseContext(),e&&e.parentNode&&e.parentNode.removeChild(e)}catch(e){console.warn("Error during WebGL cleanup:",e)}D.current=null,R.current=null,P.current=null}})(),()=>{I.current&&(I.current(),I.current=null)}}),[T,e,n,r,f,d,v,m,g,y,h,p,C]),(0,t.useEffect)((()=>{if(!R.current||!x.current||!D.current)return;const t=R.current,o=D.current;t.raysColor.value=c(n),t.raysSpeed.value=r,t.lightSpread.value=f,t.rayLength.value=d,t.pulsating.value=v?1:0,t.fadeDistance.value=m,t.saturation.value=g,t.mouseInfluence.value=h,t.noiseAmount.value=p,t.distortion.value=C;const{clientWidth:a,clientHeight:i}=x.current,s=o.dpr,{anchor:u,dir:y}=l(e,a*s,i*s);t.rayPos.value=u,t.rayDir.value=y}),[n,r,f,e,d,v,m,g,h,p,C]),(0,t.useEffect)((()=>{const e=e=>{if(!x.current||!D.current)return;const n=x.current.getBoundingClientRect(),r=(e.clientX-n.left)/n.width,t=(e.clientY-n.top)/n.height;S.current={x:r,y:t}};if(y)return window.addEventListener("mousemove",e),()=>window.removeEventListener("mousemove",e)}),[y]),(0,u.jsx)("div",{ref:x,className:`light-rays-container ${w}`.trim()})}}}]);