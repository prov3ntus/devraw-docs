"use strict";(self.webpackChunkdevraw_docs=self.webpackChunkdevraw_docs||[]).push([[458],{8227:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"scripting/fundamentals/variables","title":"Variables","description":"Variables in GSC - everything you need to know.","source":"@site/docs/scripting/fundamentals/variables.mdx","sourceDirName":"scripting/fundamentals","slug":"/scripting/fundamentals/variables","permalink":"/scripting/fundamentals/variables","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/scripting/fundamentals/variables.mdx","tags":[],"version":"current","frontMatter":{"sidebar_label":"Variables","description":"Variables in GSC - everything you need to know.","slug":"/scripting/fundamentals/variables"},"sidebar":"tutorialSidebar","previous":{"title":"Control Structures","permalink":"/scripting/fundamentals/control-structures"},"next":{"title":"Tutorials","permalink":"/category/tutorials"}}');var a=n(4848),r=n(8453);const i={sidebar_label:"Variables",description:"Variables in GSC - everything you need to know.",slug:"/scripting/fundamentals/variables"},o="Variables",l={},d=[{value:"Constants",id:"constants",level:2},{value:"Data Types",id:"data-types",level:2},{value:"Variable Scope",id:"variable-scope",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",hr:"hr",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"variables",children:"Variables"})}),"\n",(0,a.jsx)(t.p,{children:"Variables (in programming) are like little containers that can store information for you. They enable developers to store something away in RAM, label it with a name, and then access it later. Just like storing something in a labelled box."}),"\n",(0,a.jsx)(t.p,{children:"If I wanted to store some data, I'd stick it in a box and slap a label on it. Then if I wanted to retrieve a value from a box, I'd find the box with the correct label on it and take the value back out again."}),"\n",(0,a.jsxs)(t.p,{children:["The place we store all our boxes is the ",(0,a.jsx)(t.strong,{children:"computer's memory"})," (the RAM), and the labels we give the boxes are our ",(0,a.jsx)(t.strong,{children:"variable names"}),". Finding the box and reading the value is the equivalent of accessing and calling the variable."]}),"\n",(0,a.jsx)(t.admonition,{title:"Naming rules",type:"info",children:(0,a.jsx)(t.p,{children:"Variable names can't have spaces or special characters in, and can't start with a number."})}),"\n","\n",(0,a.jsxs)(t.p,{children:["Variables can ",(0,a.jsx)(t.strong,{children:"change what they're storing"})," while the code is running (during runtime). In some programming languages, when you redefine a variable, the ",(0,a.jsx)(t.a,{href:"#data-types",children:"data type"})," stored in that variable can't change. So you can't create a variable that stores an ",(0,a.jsx)(t.code,{children:"int"})," value of 4, then try to redefine the variable and put a ",(0,a.jsx)(t.code,{children:"float"})," (decimal) value of 6.5 in there."]}),"\n",(0,a.jsxs)(t.p,{children:["These types of programming languages are referred to as ",(0,a.jsx)(t.strong,{children:"static"})," languages. For these languages, the ",(0,a.jsx)(t.a,{href:"#data-types",children:"data types"})," of variables are defined at compile time and can't be changed during runtime. You can still change what data is in the variable, just not the type."]}),"\n",(0,a.jsxs)(t.p,{children:["In dynamically-typed languages, however, you can redefine variables with whatever you want and don't have to worry about data types. ",(0,a.jsx)(t.strong,{children:"GSC is a dynamically-typed language"}),"."]}),"\n",(0,a.jsxs)(t.admonition,{title:"Does capitalisation matter?",type:"tip",children:[(0,a.jsxs)(t.p,{children:["When typing function or variable names, does it matter if I put ",(0,a.jsx)(t.code,{children:"player.name"})," or ",(0,a.jsx)(t.code,{children:"player.Name"}),"? Or even ",(0,a.jsx)(t.code,{children:"PLAYER.name"}),"? The answer is ",(0,a.jsx)(t.strong,{children:"NO"}),", in GSC they're the same variable. But this is pretty much ",(0,a.jsx)(t.strong,{children:"unique to GSC"}),"."]}),(0,a.jsxs)(t.p,{children:["GSC is one of the rare languages that is case ",(0,a.jsx)("u",{children:(0,a.jsx)(t.strong,{children:"in"})}),"sensitive, meaning that function names, variable names, etc. can be either capitalised or not, it doesn't matter. Fully capitalised variables are seen as constants though (see below)."]}),(0,a.jsxs)(t.admonition,{title:"Caution when using strings!",type:"warning",children:[(0,a.jsxs)(t.p,{children:["Strings are ",(0,a.jsx)(t.strong,{children:"always"})," case-sensitive, no matter what language you're writing. For example, the string ",(0,a.jsx)(t.code,{children:'"Hello World"'})," is NOT the same as ",(0,a.jsx)(t.code,{children:'"hello world"'}),"."]}),(0,a.jsxs)(t.p,{children:["The comparison operation ",(0,a.jsx)(t.code,{children:'"LOOK AT ME" == "look at me"'})," will ",(0,a.jsx)(t.em,{children:"always"})," return false."]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"constants",children:"Constants"}),"\n",(0,a.jsxs)(t.p,{children:["Usually when you see fully CAPITALISED variables in a script, it's a ",(0,a.jsx)(t.a,{href:"/scripting/fundamentals/macros#macros",children:"macro"})," / constant. Constants are variables that ",(0,a.jsx)(t.strong,{children:"don't change what they're storing"}),". In general for programming, it's widely accepted that constants are fully capitalised to show that they're a constant. Otherwise, when we call it, it's often ",(0,a.jsx)(t.strong,{children:"hard to tell whether it's a variable or a constant"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Defining a constant:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-gsc",metastring:'title="share\\raw\\scripts\\zm\\zm_weapons.gsc --\x3e get_ammo_cost_for_weapon()"',children:"const N_WALLBUY_UPGRADE_COST = 4000;\n"})}),"\n",(0,a.jsxs)(t.p,{children:["You ",(0,a.jsx)(t.em,{children:"can"})," define and call a constant without naming it in full caps, but it's bad practice to do so, as explained above."]}),"\n",(0,a.jsx)(t.p,{children:"The reason we use constants is because they can be more efficient than variables; the program knows exactly what that piece of information is because it can't be redefined, so it doesn't have to wait while it's fetched from memory. Therefore constants can be slightly faster to use than variables. They are also a way to communicate to other developers (or even yourself in the future) that this memory should not be redefined. If another developer (or your future self) tries to redefine the constant, an error will be thrown."}),"\n",(0,a.jsxs)(t.p,{children:["However, it's ",(0,a.jsx)(t.strong,{children:"completely optional to use constants"}),". Don't think that you have to make every variable that isn't redefined a constant. The only reason I've included them in this documentation is so that if someone wants to understand them, they can do so here."]}),"\n",(0,a.jsxs)(t.p,{children:["In the stock scripts we were given in Mod Tools, there are about ",(0,a.jsx)(t.strong,{children:"120"})," constants defined, whereas there are over ",(0,a.jsx)(t.strong,{children:"20,000"})," variables defined. Therefore, variables are used over 160 times more than constants. In other words, ",(0,a.jsx)(t.em,{children:"you don't need to use constants very often,"})," if at all."]}),"\n",(0,a.jsxs)(t.p,{children:["While constants still suffer from their function-bound ",(0,a.jsx)(t.a,{href:"#variable-scope",children:"variable scope"}),", a macro is accessible script-wide. Macros are used in specific scenarios and can often be more useful than constants. Read the macros section ",(0,a.jsx)(t.a,{href:"/scripting/fundamentals/macros#macros",children:"here"})," for more info on that."]}),"\n",(0,a.jsx)(t.h2,{id:"data-types",children:"Data Types"}),"\n",(0,a.jsx)(t.p,{children:"There are lots of different data types. Some are exclusive to some languages, others are shared with all languages."}),"\n",(0,a.jsx)(t.p,{children:"In GSC, the main data types are:"}),"\n",(0,a.jsxs)(t.table,{children:[(0,a.jsx)(t.thead,{children:(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.th,{style:{textAlign:"center"},children:"Data Type"}),(0,a.jsx)(t.th,{children:"Definition"}),(0,a.jsx)(t.th,{style:{textAlign:"center"},children:"Examples"})]})}),(0,a.jsxs)(t.tbody,{children:[(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"String"}),(0,a.jsxs)(t.td,{children:["A sequence of characters / symbols / digits; a piece of text, surrounded by quotes (",(0,a.jsx)(t.code,{children:'"'}),"), unless it's in a variable. The ",(0,a.jsx)(t.a,{href:"/faq#engine-functions",children:"engine function"})," ",(0,a.jsx)(t.code,{children:"IsStr( <arg> )"})," will return true if ",(0,a.jsx)(t.code,{children:"<arg>"})," is a string."]}),(0,a.jsxs)(t.td,{style:{textAlign:"center"},children:[(0,a.jsx)(t.code,{children:'"This is a string!"'}),", ",(0,a.jsx)(t.code,{children:'"10"'}),", ",(0,a.jsx)(t.code,{children:'"trigger_activated"'})]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"Integer"}),(0,a.jsxs)(t.td,{children:["A ",(0,a.jsx)(t.em,{children:"whole"})," number. Can be positive or negative. ",(0,a.jsx)(t.strong,{children:"No fractional or decimal values."})]}),(0,a.jsxs)(t.td,{style:{textAlign:"center"},children:[(0,a.jsx)(t.code,{children:"-128"}),", ",(0,a.jsx)(t.code,{children:"69420"}),", ",(0,a.jsx)(t.code,{children:"0"}),", ",(0,a.jsx)(t.code,{children:"1"}),", ",(0,a.jsx)(t.code,{children:"115"})]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"Floating point"}),(0,a.jsxs)(t.td,{children:["A ",(0,a.jsx)(t.em,{children:"decimal / fractional"})," number. Can be positive or negative. Whole numbers are also allowed."]}),(0,a.jsxs)(t.td,{style:{textAlign:"center"},children:[(0,a.jsx)(t.code,{children:"15.67525"}),", ",(0,a.jsx)(t.code,{children:"3.1415926"}),", ",(0,a.jsx)(t.code,{children:"4.0"}),", ",(0,a.jsx)(t.code,{children:".05"}),", ",(0,a.jsx)(t.code,{children:"12."}),", ",(0,a.jsx)(t.code,{children:".0"})]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"Boolean"}),(0,a.jsxs)(t.td,{children:["True or false values. Boolean values can be treated as ",(0,a.jsx)(t.code,{children:"1"})," or ",(0,a.jsx)(t.code,{children:"0"})," thanks to GSC being a dynamically-typed language. It's recommended not to use ",(0,a.jsx)(t.code,{children:"1"})," instead of ",(0,a.jsx)(t.code,{children:"true"})," (and vice versa) for clarity and readability (you'll also get mocked by any decent programmer that sees you use ",(0,a.jsx)(t.code,{children:"1"})," instead of ",(0,a.jsx)(t.code,{children:"true"})," for boolean values)."]}),(0,a.jsxs)(t.td,{style:{textAlign:"center"},children:[(0,a.jsx)(t.code,{children:"true"}),", ",(0,a.jsx)(t.code,{children:"false"})]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"Array"}),(0,a.jsxs)(t.td,{children:["A list of items in an index (a specific order), structured as key-value pairs. Default index keys is ",(0,a.jsx)(t.code,{children:"0"})," to ",(0,a.jsx)(t.code,{children:"n - 1"}),", where ",(0,a.jsx)(t.code,{children:"n"})," is the length of the array. Keys can be any data type, and must be unique. In GSC, they can hold ",(0,a.jsx)(t.em,{children:"multiple data types at once"}),". Similar to Python's dictionaries / lists."]}),(0,a.jsx)(t.td,{style:{textAlign:"center"},children:(0,a.jsx)(t.code,{children:"my_array = []"})})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"Vector"}),(0,a.jsx)(t.td,{children:"A group of three float values. Commonly used to store transforms, i.e. an object's position (origin) or its angles. Transforms are in the format ( x, y, z )"}),(0,a.jsxs)(t.td,{style:{textAlign:"center"},children:[(0,a.jsx)(t.code,{children:"player.origin"}),", ",(0,a.jsx)(t.code,{children:"player.angles"}),", `( 126,  )"]})]}),(0,a.jsxs)(t.tr,{children:[(0,a.jsx)(t.td,{style:{textAlign:"center"},children:"Undefined"}),(0,a.jsxs)(t.td,{children:["This isn't really a data type per se, but the ",(0,a.jsx)(t.code,{children:"undefined"})," key word is used to declare that a variable holds nothing inside it. Using the metaphor from the ",(0,a.jsx)(t.a,{href:"#variables",children:"variables"})," section, you can think of assigning ",(0,a.jsx)(t.code,{children:"undefined"})," to a variable as emptying the box. If you try to call a variable that doesn't exist / has never been defined before, it will return ",(0,a.jsx)(t.code,{children:"undefined"}),". You can use the engine function ",(0,a.jsx)(t.code,{children:"isdefined( <var> )"})," to check if a variable (",(0,a.jsx)(t.code,{children:"<var>"}),") is defined or not."]}),(0,a.jsx)(t.td,{style:{textAlign:"center"},children:(0,a.jsx)(t.code,{children:"time = undefined;"})})]})]})]}),"\n",(0,a.jsx)(t.h2,{id:"variable-scope",children:"Variable Scope"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.em,{children:"// TODO"})}),"\n",(0,a.jsx)(t.hr,{}),"\n",(0,a.jsx)("br",{})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var s=n(6540);const a={},r=s.createContext(a);function i(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);